#line 8 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif

#include "HLSLSupport.cginc"
#include "UnityShaderVariables.cginc"
#line 8 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif

 
         // #pragma vertex vert  
         // #pragma fragment frag 
 
         #include "UnityCG.cginc"
 
         uniform float4 _LightColor0; 

 
         uniform float4 _Color;
         uniform sampler2D _MainTex;

         static float3 normArray[6] = 
         {
         	float3(0,0,1), float3(0,0,-1), float3(-1,0,0), float3(1,0,0), float3(0,1,0), float3(0,-1,0)
         };

 
         struct vertexInput {
            float4 vertex : POSITION;
            float2 uv	  : TEXCOORD0;
         };
         struct vertexOutput {
            float4 pos : SV_POSITION;
            float4 col : COLOR;
            float2 uv  : TEXCOORD0;
         };
 
         vertexOutput vert(vertexInput input) 
         {
            vertexOutput output;
 
            float4x4 modelMatrix = _Object2World;
            float4x4 modelMatrixInverse = _World2Object;
 
 			uint packedInfo =  floatBitsToUint( input.uv.x );
 			float uv_y = (uint)(packedInfo & 0xF);
			float uv_x = (uint)((packedInfo >> 4) & 0xF);
			output.uv = float2(uv_x, uv_y);
			
			
			uint normIndex = (uint)((packedInfo >> 8) & 0x7);
 
            float3 normalDirection = normalize(
               mul(float4(normArray[ normIndex ], 0.0), modelMatrixInverse).xyz);
            float3 lightDirection = normalize(_WorldSpaceLightPos0.xyz);
 
            float3 diffuseReflection = _LightColor0.rgb
               * max(0.0, dot(normalDirection, lightDirection));
 
            output.col = float4(diffuseReflection, 1.0);
            output.pos = mul(UNITY_MATRIX_MVP, input.vertex);
            return output;
         }
 
         float4 frag(vertexOutput input) : COLOR
         {
         	float4 c = tex2D(_MainTex, input.uv);
            return input.col * c;
         }
 
         